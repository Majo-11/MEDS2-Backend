# Este código es para tu BACKEND (servidor), no para el frontend HTML/JS.
# Deberías ejecutarlo en el entorno de Render.com donde tienes tu backend.

from flask import Flask, request, jsonify
from pymongo import MongoClient
from pymongo.server_api import ServerApi
from datetime import datetime # Para manejar fechas si es necesario

app = Flask(__name__)

# --- Tu función de conexión a MongoDB ---
def connect_to_mongodb(db_name, collection_name):
    # ¡IMPORTANTE! Reemplaza '<a315-55g>' con tu contraseña real de MongoDB Atlas.
    # Es altamente recomendable usar variables de entorno para las credenciales en un entorno de producción.
    uri = "mongodb+srv://mariajopineda:<a315-55g>@cluster0.7uchx.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0"
    client = MongoClient(uri, server_api=ServerApi('1'))
    db = client[db_name]
    collection = db[collection_name]
    return collection

# --- Configuración de CORS (Crucial para que tu frontend pueda comunicarse con el backend) ---
# Esto permite que tu frontend (que está en un dominio diferente) envíe solicitudes a tu backend.
@app.after_request
def add_cors_headers(response):
    response.headers.add('Access-Control-Allow-Origin', '*') # Permite solicitudes desde cualquier origen
    response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
    response.headers.add('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS')
    return response

# --- Ruta para manejar las solicitudes de MedicationRequest ---
@app.route('/medication-request', methods=['POST'])
def handle_medication_request():
    # 1. Verificar que la solicitud es POST y tiene un cuerpo JSON
    if request.method == 'POST':
        try:
            data = request.get_json() # Obtiene el cuerpo JSON de la solicitud
            if not data:
                return jsonify({"message": "No se recibieron datos JSON válidos"}), 400

            # --- DEBUGGING: Imprime los datos recibidos en los logs del backend ---
            print(f"Datos recibidos del frontend: {data}")

            # 2. Conectar a la colección de MongoDB
            # Puedes elegir los nombres de tu base de datos y colección aquí
            medication_collection = connect_to_mongodb('medsdb', 'medicationrequests')

            # 3. Preparar los datos para MongoDB
            # MongoDB puede manejar directamente el objeto JSON que envías.
            # Sin embargo, si tienes campos de fecha, es bueno convertirlos a objetos datetime.
            if 'deliveryDetails' in data and 'deliveryDate' in data['deliveryDetails'] and data['deliveryDetails']['deliveryDate']:
                try:
                    # Convierte la cadena de fecha (YYYY-MM-DD) a un objeto datetime
                    data['deliveryDetails']['deliveryDate'] = datetime.strptime(data['deliveryDetails']['deliveryDate'], '%Y-%m-%d')
                except ValueError:
                    return jsonify({"message": "Formato de fecha de entrega inválido. Use YYYY-MM-DD."}), 400

            # 4. Insertar los datos en la colección
            result = medication_collection.insert_one(data)

            # --- DEBUGGING: Imprime el ID del documento insertado ---
            print(f"Documento insertado con ID: {result.inserted_id}")

            # 5. Enviar una respuesta al frontend
            return jsonify({
                "message": "Receta y detalles de entrega registrados exitosamente en MongoDB",
                "inserted_id": str(result.inserted_id) # Convertir ObjectId a string para JSON
            }), 201 # 201 Created

        except Exception as e:
            # Manejo de errores
            print(f"Error en el backend al procesar la solicitud: {e}")
            return jsonify({"message": f"Error interno del servidor: {str(e)}"}), 500
    else:
        # Manejar otros métodos HTTP si es necesario (ej. OPTIONS para preflight CORS)
        return jsonify({"message": "Método no permitido"}), 405

if __name__ == '__main__':
    # Asegúrate de que Flask escuche en todas las interfaces para Render.com
    # O usa Gunicorn/Waitress en producción
    app.run(host='0.0.0.0', port=5000) # O el puerto que Render.com asigne